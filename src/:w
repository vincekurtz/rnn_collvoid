#!/usr/bin/env python

##
#
# Train a simple LSTM RNN to predict future
# positions based on current position and velocity. 
#
#
##

import csv
import numpy as np
import tensorflow as tf
from data_container import DataContainer
import tensorflow as tf
import numpy as np
import rospy
from nav_msgs.msg import Odometry

TIMESTEP = 0.1   # seconds between samples

# Define all global variables that make up our network structure
INPUT_SIZE = 2   # last changes 2D change in position
OUTPUT_SIZE = 2   # Next 2D change in position
RNN_HIDDEN = 100
LEARNING_RATE = 0.003

inputs = tf.placeholder(tf.float32, (None, None, INPUT_SIZE))
outputs = tf.placeholder(tf.float32, (None, None, OUTPUT_SIZE))

# Create a basic LSTM cell, there are other options too
cell = tf.nn.rnn_cell.BasicLSTMCell(RNN_HIDDEN, state_is_tuple=True)
#cell = tf.nn.rnn_cell.BasicRNNCell(RNN_HIDDEN)

# Add dropout
cell = tf.nn.rnn_cell.DropoutWrapper(
	cell,
	input_keep_prob=0.9,
	output_keep_prob=0.9,
	state_keep_prob=0.9,
	variational_recurrent=True,
	input_size=INPUT_SIZE,
	dtype=tf.float32,
	seed=None
)

# Create initial state as all zeros
batch_size = 1  # because online learning
initial_state = cell.zero_state(batch_size, tf.float32)

# Given a set of inputs, return a tuple with rnn outputs and rnn state
rnn_outputs, rnn_states = tf.nn.dynamic_rnn(cell, inputs, initial_state=initial_state, time_major=True)

# Project rnn outputs to our OUTPUT_SIZE
final_projection = lambda x: tf.contrib.layers.linear(x, num_outputs=OUTPUT_SIZE, activation_fn=None)
predicted_outputs = tf.map_fn(final_projection, rnn_outputs)

# Compute the error that we want to minimize
error = tf.losses.huber_loss(outputs, predicted_outputs)
#error = tf.losses.absolute_difference(outputs, predicted_outputs)

# Optimization
train_fn = tf.train.AdamOptimizer(learning_rate=LEARNING_RATE).minimize(error)

# Accuracy measurment
accuracy = tf.reduce_mean(tf.abs(outputs - predicted_outputs))

# TRAINING DATA: these variables are updated in real time
last_x = None
last_y = None
X = None
Y = None

last_time = None  # so we only keep track of data so often

def odom_callback(data):
    """
    Updates the globally stored training data
    """
    global X  # input
    global Y  # output
    global last_x  # x position
    global last_y  # y position
    global last_time

    if last_time is None:
        # initialize the time counter: this must happen
        # after the node an everything is started
        last_time = rospy.get_time()

    if (rospy.get_time() > last_time + TIMESTEP):
        curr_x = data.pose.pose.position.x
        curr_y = data.pose.pose.position.y

        if last_x is not None:
            deltax = curr_x - last_x
            deltay = curr_y - last_y

            if X is not None:
                X = np.vstack((X, np.array([[deltax, deltay]])))
            else:
                X = np.array([[deltax, deltay]])

        last_x = curr_x
        last_y = curr_y
        last_time = rospy.get_time()

def train(datafile):
    """
    Run the Training Loop!

    Assues that global network variables (as in network_variables.py) are defined
    """

    NUM_EPOCHS = 100
    ITERATIONS_PER_EPOCH = 10
    NUM_STEPS = 100
    BATCH_SIZE = 1

    mydata = DataContainer(datafile)

    with tf.Session() as session:
        session.run(tf.global_variables_initializer())

        for epoch in range(NUM_EPOCHS):
            epoch_error = 0
            mydata.reset()   # retrain on the same data just for now, for testing purposes
            for _ in range(ITERATIONS_PER_EPOCH):
                # Get training data for the next batch
                fullx, fully = mydata.get_next_batch(NUM_STEPS, BATCH_SIZE, add_noise=True)
                print(x,y)

                # train_fn triggers backprop
                epoch_error += session.run([error, train_fn], { inputs: x, outputs: y})[0]

            epoch_error /= ITERATIONS_PER_EPOCH
            print("Epoch %d, train error: %.6f" % (epoch, epoch_error))

if __name__=="__main__":
    #datafile = "/home/vjkurtz/catkin_ws/src/rnn_collvoid/data/test_data.csv"
    #train(datafile)
    try:
        rospy.init_node('rnn_data_collector')
        odom = rospy.Subscriber('/robot_0/base_pose_ground_truth', Odometry, odom_callback)

        while not rospy.is_shutdown():
            rospy.sleep(1)
            print(X.shape)

    except rospy.ROSInterruptException:
        pass
