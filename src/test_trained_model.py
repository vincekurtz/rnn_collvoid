#!/usr/bin/env python

##
# 
#  Load a trained model (generated by train_lstm.py) and
#  run some tests on it
#
##

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.collections import PatchCollection
from data_container import DataContainer
from network_variables import *

def plot_trajectory(traj):
    """
    Make a matplotlib plot of the path of the robot
    given a list of changes in position (could be predicted or actual)
    """
    # Set up axes
    figs, axes = plt.subplots(2,1)
    (ax1, ax2) = axes

    radius = .2
    x = 0  # define initial position at the origin
    y = 0
    patches = []
    xs = []
    ys = []
    t = 0
    time = [t + 1 for i in range(len(traj))]
    print(len(time))

    # Unpack the data
    for delta in traj:
        x = x + delta[0][0]
        y = y + delta[0][1]
        circle = Circle((x,y), radius)
        patches.append(circle)
        xs.append(x)
        ys.append(y)

    # Plot state space trajectory
    p = PatchCollection(patches, alpha=0.4)
    ax1.add_collection(p)
    ax1.autoscale_view()
    ax1.set_title("State Space Trajectory")
    ax1.set_xlabel("x")
    ax1.set_ylabel("y")

    # Plot x, y positions vs time
    ax2.plot(xs)
    ax2.plot(ys)
    ax2.set_title("Position vs Time")

    plt.show()

def plot_comparison(predicted_trajectories, actual_trajectory):
    """
    Plot multiple predicted trajectories (i.e. those generated with
    dropout) and one actual trajectory.

    Assumes that actual_trajectory (and each element of predicted_trajectories)
    were created using a batch size of one. 
    """
    N = len(predicted_trajectories)  # the number of different predictions
 
    # Set up multiple axes
    figs, axes = plt.subplots(2,1)
    (ax1, ax2) = axes
    ax1.set_title("X position change")
    ax2.set_title("Y position change")

    actual_x = actual_trajectory[:,0,0]
    actual_y = actual_trajectory[:,0,1]

    for i in range(N):
        pred_x = predicted_trajectories[i][:,0,0]
        pred_y = predicted_trajectories[i][:,0,1]
        ax1.plot(pred_x, color="b", alpha=0.5)
        ax2.plot(pred_y, color="b", alpha=0.5)

    ax1.plot(actual_x, color="r")
    ax1.set_xlabel("timestep")
    ax1.set_ylabel("position change")
    ax2.plot(actual_y, color="r")
    ax2.set_xlabel("timestep")
    ax2.set_ylabel("position change")
    plt.show()

if __name__=="__main__":
    with tf.Session() as sess:
        # Initialize global variables
        sess.run(tf.global_variables_initializer())

        # Load saved session
        saver = tf.train.Saver()
        saver.restore(sess, "%s/tmp/LSTM_saved_model" % base_dir)

        # Load test/validation data
        test_set = DataContainer(test_set_file)
        inpt, otpt = test_set.get_next_batch(num_steps=100, batch_size=1, dataset="Test")

        # Plot predicted and actual trajectory 
        predicts = [] 
        N = 100   # number of dropout samples to use
        for i in range(N):
            pred = sess.run(predicted_outputs, { inputs: inpt, outputs: otpt })
            predicts.append(pred)

        plot_comparison(predicts, otpt)
        plot_trajectory(otpt)
