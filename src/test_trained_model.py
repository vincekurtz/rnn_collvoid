#!/usr/bin/env python

##
# 
#  Load a trained model (generated by train_lstm.py) and
#  run some tests on it
#
##

import tensorflow as tf
import numpy as np
from train_lstm import *

base_dir = "/home/vjkurtz/catkin_ws/src/rnn_collvoid"
test_set_file = "%s/data/test_data.csv" % base_dir

# Define all global variables that make up our network structure

INPUT_SIZE = 2   # x and y velocities
OUTPUT_SIZE = 2   # x and y positions
RNN_HIDDEN = 256
LEARNING_RATE = 0.01

inputs = tf.placeholder(tf.float32, (None, None, INPUT_SIZE))
outputs = tf.placeholder(tf.float32, (None, None, OUTPUT_SIZE))

# Create a basic LSTM cell, there are other options too
cell = tf.nn.rnn_cell.BasicLSTMCell(RNN_HIDDEN, state_is_tuple=True)

# Add dropout
cell = tf.nn.rnn_cell.DropoutWrapper(
	cell,
	input_keep_prob=0.9,
	output_keep_prob=0.9,
	state_keep_prob=1.0,
	variational_recurrent=False,
	input_size=INPUT_SIZE,
	dtype=tf.float32,
	seed=None
)

# Create initial state as all zeros
batch_size = tf.shape(inputs)[1]
initial_state = cell.zero_state(batch_size, tf.float32)

# Given a set of inputs, return a tuple with rnn outputs and rnn state
rnn_outputs, rnn_states = tf.nn.dynamic_rnn(cell, inputs, initial_state=initial_state, time_major=True)

# Project rnn outputs to our OUTPUT_SIZE
final_projection = lambda x: tf.contrib.layers.linear(x, num_outputs=OUTPUT_SIZE, activation_fn=None)
predicted_outputs = tf.map_fn(final_projection, rnn_outputs)

# Compute the error that we want to minimize
error = tf.losses.huber_loss(outputs, predicted_outputs)

# Optimization
train_fn = tf.train.AdamOptimizer(learning_rate=LEARNING_RATE).minimize(error)

# Accuracy measurment
accuracy = tf.reduce_mean(tf.abs(outputs - predicted_outputs))


with tf.Session() as sess:
    # Initialize global variables
    sess.run(tf.global_variables_initializer())

    # Load saved session
    saver = tf.train.Saver()
    saver.restore(sess, "%s/tmp/LSTM_saved_model" % base_dir)

    # Load test/validation data
    test_set = DataContainer(test_set_file)
    inpt, otpt = test_set.get_next_batch(num_steps=100, batch_size=1, dataset="Test")

    # Plot predicted and actual trajectory 
    predicts = [] 
    N = 100   # number of dropout samples to use
    for i in range(N):
        pred = sess.run(predicted_outputs, { inputs: inpt, outputs: otpt })
        predicts.append(pred)

    plot_comparison(predicts, otpt)
