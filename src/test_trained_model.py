#!/usr/bin/env python

##
# 
#  Load a trained model (generated by train_lstm.py) and
#  run some tests on it
#
##

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cmx
import matplotlib.colors as colors
from matplotlib.patches import Circle
from matplotlib.collections import PatchCollection
from data_container import DataContainer
from network_variables import *
    
base_dir = "/home/vjkurtz/catkin_ws/src/rnn_collvoid" 

def plot_trajectory(traj):
    """
    Make a matplotlib plot of the path of the robot
    given a list of changes in position (could be predicted or actual)
    """
    # Set up axes
    figs, axes = plt.subplots(2,1)
    (ax1, ax2) = axes

    radius = .2
    x = 0  # define initial position at the origin
    y = 0
    patches = []
    xs = []
    ys = []
    t = 0
    time = [t + 1 for i in range(len(traj))]
    print(len(time))

    # Unpack the data
    for delta in traj:
        x = x + delta[0][0]
        y = y + delta[0][1]
        circle = Circle((x,y), radius)
        patches.append(circle)
        xs.append(x)
        ys.append(y)

    # Plot state space trajectory
    p = PatchCollection(patches, alpha=0.4)
    ax1.add_collection(p)
    ax1.autoscale_view()
    ax1.set_title("State Space Trajectory")
    ax1.set_xlabel("x")
    ax1.set_ylabel("y")

    # Plot x, y positions vs time
    ax2.plot(xs)
    ax2.plot(ys)
    ax2.set_title("Position vs Time")

    plt.show()

def plot_comparison(predicted_trajectories, actual_trajectory):
    """
    Plot multiple predicted trajectories (i.e. those generated with
    dropout) and one actual trajectory.

    Assumes that actual_trajectory (and each element of predicted_trajectories)
    were created using a batch size of one. 
    """
    N = len(predicted_trajectories)  # the number of different predictions
 
    # Set up multiple axes
    figs, axes = plt.subplots(2,2)
    ax1 = axes[0,0]
    ax2 = axes[1,0]
    ax3 = axes[0,1]
    ax4 = axes[1,1]
    ax1.set_title("X position change")
    ax2.set_title("Y position change")
    ax3.set_title("X velocity")
    ax4.set_title("Y velocity")

    actual_x = actual_trajectory[:,0,0]
    actual_y = actual_trajectory[:,0,1]
    actual_dx = actual_trajectory[:,0,2]
    actual_dy = actual_trajectory[:,0,3]

    for i in range(N):
        pred_x = predicted_trajectories[i][:,0,0]
        pred_y = predicted_trajectories[i][:,0,1]
        pred_dx = predicted_trajectories[i][:,0,2]
        pred_dy = predicted_trajectories[i][:,0,3]
        ax1.plot(pred_x, color="b", alpha=0.5)
        ax2.plot(pred_y, color="b", alpha=0.5)
        ax3.plot(pred_dx, color="b", alpha=0.5)
        ax4.plot(pred_dy, color="b", alpha=0.5)

    ax1.plot(actual_x, color="r")
    #ax1.set_xlabel("timestep")
    #ax1.set_ylabel("position change")
    ax2.plot(actual_y, color="r")
    #ax2.set_xlabel("timestep")
    #ax2.set_ylabel("position change")
    ax3.plot(actual_dx, color="r")
    ax4.plot(actual_dy, color="r")

    # set axes limits
    ax1.set_ylim(-0.4,0.4)
    ax2.set_ylim(-0.4,0.4)
    ax3.set_ylim(-2, 2)
    ax4.set_ylim(-0.4, 0.4)

    plt.show()

def get_predictions(observations, num_pred):
    """
    Given a sequence of observations, use dropout to generate num_pred unique outputs

    Returns:
        a list of num_pred outputs
        a list of num_pred updated observation sequences 
    """
    outputs = []
    new_observations = []

    with tf.Session() as sess:
        # Initialize global variables
        sess.run(tf.global_variables_initializer())

        # Load saved session
        saver = tf.train.Saver()
        saver.restore(sess, "%s/tmp/LSTM_saved_model" % base_dir)

        for i in range(num_pred):
            # This gives a (num_steps x batch_size x output_size), ie (100 x 1 x 4), numpy array. 
            all_pred = sess.run(predicted_outputs, { inputs: observations })
            # We're really only interested in the last prediction: the one for the next step
            next_pred = all_pred[-1][0]   # [deltax, deltay, xdot1, ydot1] 
            
            # Update velocities for the next time step
            next_obs = np.append(observations[1:], [[ next_pred[2:] ]], axis=0)

            outputs.append(next_pred)
            new_observations.append(next_obs)

    return (outputs, new_observations)


def funnel_test():
    """
    Based on an initial observation, propagate an estimate of position forward
    in time. Do this several times repeatedly to generate a funnel
    """
    test_set_file = "%s/data/test_data.csv" % base_dir 

    with tf.Session() as sess:
        # Initialize global variables
        sess.run(tf.global_variables_initializer())

        # Load saved session
        saver = tf.train.Saver()
        saver.restore(sess, "%s/tmp/LSTM_saved_model" % base_dir)

        # Load initial observations
        test_set = DataContainer(test_set_file)
        observations, _ = test_set.get_next_batch(num_steps=100, batch_size=1, dataset="Test", add_noise=True)  # we'll ignore the actual output data in this case


        # Plot predicted next positions
        num_runs = 50
        run_length = 25

        # Matplotlib setup to change colors as we move along the trajectory
        color_map = cmx.ScalarMappable(
                norm = colors.Normalize(vmin=0, vmax=run_length),
                cmap = plt.get_cmap('jet')
                )

        for j in range(num_runs):
            # Set starting position
            x = 0
            y = 0
            for i in range(run_length):
                # This gives a (num_steps x batch_size x output_size), ie (100 x 1 x 4), numpy array. 
                all_pred = sess.run(predicted_outputs, { inputs: observations, outputs: _ })
                # We're really only interested in the last prediction: the one for the next step
                next_pred = all_pred[-1][0]   # [deltax, deltay, xdot1, ydot1] 

                # Update positions
                x += next_pred[0]
                y += next_pred[1]

                # Update velocities for the next time step
                observations = np.append(observations[1:], [[ next_pred[2:] ]], axis=0)
                
                # add to the plot
                point_color = color_map.to_rgba(i)
                plt.scatter(x,y, color=point_color)
       
        plt.xlabel("x position")
        plt.ylabel("y position")
        plt.show()


def simple_test_with_forward_propagation():
    """
    Plot output, but with past inputs propagated forward
    """
    test_set_file = "%s/data/test_data.csv" % base_dir 
    test_set = DataContainer(test_set_file)

    initial_input, initial_output = test_set.get_next_batch(num_steps=100, batch_size=1, dataset="Test")


def funnel_test_two():
    """
    Based on an initial observation, propagate an estimate of position forward
    in time. Do this by generating several predictions, then propagating forward several predictions
    for each of those, in a tree-like manner
    """
    num_samples = 2
    test_set_file = "%s/data/test_data.csv" % base_dir 
    
    # Load initial observations
    test_set = DataContainer(test_set_file)
    observations, _ = test_set.get_next_batch(num_steps=100, batch_size=1, dataset="Test")  # we'll ingore the actual output data in this case

    # Plot the initial point, which we take to be the origin
    
    
    pred, new_obs = get_predictions(observations, num_samples)
    for i in range(num_samples):
        plt.scatter(pred[i][0], pred[i][1])  # plot x and y for this round
        
    plt.show()


def simple_test():
    """
    Simply plot input and output
    """
    test_set_file = "%s/data/test_data.csv" % base_dir 

    with tf.Session() as sess:
        # Initialize global variables
        sess.run(tf.global_variables_initializer())

        # Load saved session
        saver = tf.train.Saver()
        saver.restore(sess, "%s/tmp/LSTM_saved_model" % base_dir)

        # Load test/validation data
        test_set = DataContainer(test_set_file)
        inpt, otpt = test_set.get_next_batch(num_steps=100, batch_size=1, dataset="Test")

        # Plot predicted and actual trajectory 
        predicts = [] 
        N = 100   # number of dropout samples to use
        for i in range(N):
            pred = sess.run(predicted_outputs, { inputs: inpt, outputs: otpt })
            predicts.append(pred)

        plot_comparison(predicts, otpt)

if __name__=="__main__":
    #simple_test()
    funnel_test()
