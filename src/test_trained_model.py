#!/usr/bin/env python

##
# 
#  Load a trained model (generated by train_lstm.py) and
#  run some tests on it
#
##

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cmx
import matplotlib.colors as colors
from matplotlib.patches import Circle
from matplotlib.collections import PatchCollection
from data_container import DataContainer
from network_variables import *
    
base_dir = "/home/vjkurtz/catkin_ws/src/rnn_collvoid" 

def plot_trajectory(traj):
    """
    Make a matplotlib plot of the path of the robot
    given a list of changes in position (could be predicted or actual)
    """
    # Set up axes
    figs, axes = plt.subplots(2,1)
    (ax1, ax2) = axes

    radius = .2
    x = 0  # define initial position at the origin
    y = 0
    patches = []
    xs = []
    ys = []
    t = 0
    time = [t + 1 for i in range(len(traj))]
    print(len(time))

    # Unpack the data
    for delta in traj:
        x = x + delta[0][0]
        y = y + delta[0][1]
        circle = Circle((x,y), radius)
        patches.append(circle)
        xs.append(x)
        ys.append(y)

    # Plot state space trajectory
    p = PatchCollection(patches, alpha=0.4)
    ax1.add_collection(p)
    ax1.autoscale_view()
    ax1.set_title("State Space Trajectory")
    ax1.set_xlabel("x")
    ax1.set_ylabel("y")

    # Plot x, y positions vs time
    ax2.plot(xs)
    ax2.plot(ys)
    ax2.set_title("Position vs Time")

    plt.show()

def plot_comparison(predicted_trajectories, actual_trajectory):
    """
    Plot multiple predicted trajectories (i.e. those generated with
    dropout) and one actual trajectory.

    Assumes that actual_trajectory (and each element of predicted_trajectories)
    were created using a batch size of one. 
    """
    N = len(predicted_trajectories)  # the number of different predictions
 
    # Set up multiple axes
    figs, axes = plt.subplots(2,2)
    ax1 = axes[0,0]
    ax2 = axes[1,0]
    ax3 = axes[0,1]
    ax4 = axes[1,1]
    ax1.set_title("X position change")
    ax2.set_title("Y position change")
    ax3.set_title("X velocity")
    ax4.set_title("Y velocity")

    actual_x = actual_trajectory[:,0,0]
    actual_y = actual_trajectory[:,0,1]
    actual_dx = actual_trajectory[:,0,2]
    actual_dy = actual_trajectory[:,0,3]

    for i in range(N):
        pred_x = predicted_trajectories[i][:,0,0]
        pred_y = predicted_trajectories[i][:,0,1]
        pred_dx = predicted_trajectories[i][:,0,2]
        pred_dy = predicted_trajectories[i][:,0,3]
        ax1.plot(pred_x, color="b", alpha=0.5)
        ax2.plot(pred_y, color="b", alpha=0.5)
        ax3.plot(pred_dx, color="b", alpha=0.5)
        ax4.plot(pred_dy, color="b", alpha=0.5)

    ax1.plot(actual_x, color="r")
    #ax1.set_xlabel("timestep")
    #ax1.set_ylabel("position change")
    ax2.plot(actual_y, color="r")
    #ax2.set_xlabel("timestep")
    #ax2.set_ylabel("position change")
    ax3.plot(actual_dx, color="r")
    ax4.plot(actual_dy, color="r")

    # set axes limits
    ax1.set_ylim(-0.4,0.4)
    ax2.set_ylim(-0.4,0.4)
    ax3.set_ylim(-2, 2)
    ax4.set_ylim(-0.4, 0.4)

    plt.show()

def get_predictions(observations, num_pred):
    """
    Given a sequence of observations, use dropout to generate num_pred unique outputs

    Returns:
        a (num_pred x output_size) np array of outputs
        a list of num_pred updated observation sequences 
    """
    outputs = []

    with tf.Session() as sess:
        # Initialize global variables
        sess.run(tf.global_variables_initializer())

        # Load saved session
        saver = tf.train.Saver()
        saver.restore(sess, "%s/tmp/LSTM_saved_model" % base_dir)

        for i in range(num_pred):
            # This gives a (num_steps x batch_size x output_size), ie (100 x 1 x 4), numpy array. 
            all_pred = sess.run(predicted_outputs, { inputs: observations })
            # We're really only interested in the last prediction: the one for the next step
            next_pred = all_pred[-1][0]   # [deltax, deltay, xdot1, ydot1] 
            
            outputs.append(next_pred)

    return np.asarray(outputs)


def funnel_test():
    """
    Based on an initial observation, propagate an estimate of position forward
    in time. Do this several times repeatedly to generate a funnel
    """
    test_set_file = "%s/data/test_data.csv" % base_dir 

    with tf.Session() as sess:
        # Initialize global variables
        sess.run(tf.global_variables_initializer())

        # Load saved session
        saver = tf.train.Saver()
        saver.restore(sess, "%s/tmp/LSTM_saved_model" % base_dir)

        # Load initial observations
        test_set = DataContainer(test_set_file)
        observations, _ = test_set.get_next_batch(num_steps=100, batch_size=1, dataset="Test", add_noise=True)  # we'll ignore the actual output data in this case


        # Plot predicted next positions
        num_runs = 20
        run_length = 25

        # Matplotlib setup to change colors as we move along the trajectory
        color_map = cmx.ScalarMappable(
                norm = colors.Normalize(vmin=0, vmax=run_length),
                cmap = plt.get_cmap('jet')
                )

        for j in range(num_runs):
            # Set starting position
            x = 0
            y = 0

            allx = []  # so we can do a line plot as well
            ally = []
            for i in range(run_length):
                # This gives a (num_steps x batch_size x output_size), ie (100 x 1 x 4), numpy array. 
                all_pred = sess.run(predicted_outputs, { inputs: observations, outputs: _ })
                # We're really only interested in the last prediction: the one for the next step
                next_pred = all_pred[-1][0]   # [deltax, deltay, xdot1, ydot1] 

                # Update positions
                x += next_pred[0]
                y += next_pred[1]

                # Update velocities for the next time step
                observations = np.append(observations[1:], [[ next_pred ]], axis=0)
                
                # add to the plot
                point_color = color_map.to_rgba(i)
                plt.scatter(x,y, color=point_color)

                allx.append(x)
                ally.append(y)

            plt.plot(allx, ally, color="grey", zorder=0)  # plot connecting lines behind dots
       
        plt.xlabel("x position")
        plt.ylabel("y position")
        plt.show()


def simple_test_with_forward_propagation():
    """
    Plot output, but with past inputs propagated forward
    """
    test_set_file = "%s/data/test_data.csv" % base_dir 
    test_set = DataContainer(test_set_file)

    initial_input, initial_output = test_set.get_next_batch(num_steps=100, batch_size=1, dataset="Test")


def funnel_test_two():
    """
    Based on an initial observation, propagate an estimate of position forward
    in time. Do this by generating several predictions, estimating an underlying
    distribution, sampling from this distribution (or taking MLE/MMSE/mean?), and using that sample to start
    the process over again.
    """
    
    test_set_file = "%s/data/test_data.csv" % base_dir 
    
    num_samples = 50  # number of samples to use to estimate the underlying distribution
    num_steps = 15   # number of steps to go into the future
    
    # Load initial observations
    test_set = DataContainer(test_set_file)
    obs, _ = test_set.get_next_batch(num_steps=50, batch_size=1, dataset="Test")  # we'll ingore the actual output data in this case

    observations = obs  # make copies 

    # Matplotlib setup to change colors as we move along the trajectory
    color_map = cmx.ScalarMappable(
            norm = colors.Normalize(vmin=0, vmax=num_steps),
            cmap = plt.get_cmap('jet')
            )

    x = 0
    y = 0
    for i in range(num_steps):
        print("Predicting step %s of %s" % (i+1, num_steps))
            
        # Get sample predictions
        predictions = get_predictions(observations, num_samples)

        # Estimate the underlying distribution
        mu = np.mean(predictions, axis=0)   # sample mean
        sigma = np.cov(predictions.T)       # sample covariance

        # Update the observations
        next_pred = mu  #np.random.multivariate_normal(mu, sigma, 1).flatten()
        observations = np.append(observations[1:], [[ next_pred ]], axis=0)
        
        # Add to the plot
        deltax, deltay, dx, dy = np.random.multivariate_normal(mu, sigma, 1000).T   # get a bunch of samples from this distribution
        point_color = color_map.to_rgba(i)
        plt.scatter(x + deltax, y + deltay, color=point_color, alpha=0.2, edgecolors="none")

        x += mu[0]  # update list of best predictions for plotting
        y += mu[1]
    
    print("Done! ... plotting ...")
    plt.show()


def simple_test():
    """
    Simply plot input and output
    """
    test_set_file = "%s/data/test_data.csv" % base_dir 

    with tf.Session() as sess:
        # Initialize global variables
        sess.run(tf.global_variables_initializer())

        # Load saved session
        saver = tf.train.Saver()
        saver.restore(sess, "%s/tmp/LSTM_saved_model" % base_dir)

        # Load test/validation data
        test_set = DataContainer(test_set_file)
        inpt, otpt = test_set.get_next_batch(num_steps=100, batch_size=1, dataset="Test")

        # Plot predicted and actual trajectory 
        predicts = [] 
        N = 100   # number of dropout samples to use
        for i in range(N):
            pred = sess.run(predicted_outputs, { inputs: inpt, outputs: otpt })
            predicts.append(pred)

        plot_comparison(predicts, otpt)

if __name__=="__main__":
    #simple_test()
    #funnel_test()
    funnel_test_two()
